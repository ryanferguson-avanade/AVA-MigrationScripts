
<#
.SYNOPSIS
    This script will run dmacmd.exe to evaluate database instances based on a csv file input.
    Version: 2020.08.01
.DESCRIPTION
    Usage: .\AVA-RunDMA.ps1 -serverCSV serverlist.csv -OutputDir c:\temp -OnPremAssessment SqlServer2016
     -serverCSV                   Csv of databases to connect to.  It has a header of ""Server,Instance,AuthMethod,UserID,Password"".  
                                        AuthMehod is either Windows or SQL
                                        Instance does not require a \
     -GenerateSampleCSV           This will create a sample CSV input file at the location of serverCSV.
     -TestOutputFile <filename>   This sets the name for the Test Output file.  The default is SQLConnectionTest.csv
     -OutputDir <outputDirectory> Directory to store all of the output files generated by this script
     -LogFile <filename>          Filename for the master log file.  Will write it into the OutputDir.  ava-rundma.log is the default.
     -TestConnections             This will try to connect to each DB and provide a success/fail result.  This is handy to run before the scan to test connectivity.
     -SQLMIAssessment             This will perform an assessment for SQLMI
     -OnPremAssessment <version>  This will perform an assessment for SQL On-Prem.  Available targets are SqlServer2012, SqlServer2014, SqlServer2016, SqlServerLinux2017 and SqlServerWindows2017
     -PaaSAssessment              This will perform an assessment for SQL PaaS
     -OverwriteOutput             When set, this will overwrite any existing assessment files.  Default is to not overwrite assessment files.
     -Help                        These usage instructions are displayed.
.LINK
    Discovery Toolkit:  https://aka.avanade.com/Discovery
.EXAMPLE
    .\AVA-RunDMA.ps1 -serverCSV serverlist.csv -GenerateSampleCSV
    Generate Sample CSV File
.EXAMPLE
    .\AVA-RunDMA.ps1 -serverCSV serverlist.csv -OutputDir c:\temp -TestConnections
    Test connections to SQL without analysis
.EXAMPLE
    .\AVA-RunDMA.ps1 -serverCSV serverlist.csv -OutputDir c:\temp -OnPremAssessment SqlServer2016
    Assess SQL for On-Prem Upgrade
.EXAMPLE
    .\AVA-RunDMA.ps1 -serverCSV serverlist.csv -OutputDir c:\temp -SQLMIAssessment -PaaSAssessment 
    Assess SQL for Cloud Upgrade  
.EXAMPLE
    .\AVA-RunDMA.ps1 -serverCSV serverlist.csv -OutputDir c:\temp -SQLMIAssessment -PaaSAssessment -OnPremAssessment SqlServer2016
    Assess SQL for All Upgrades
.NOTES
    Avanade - 2020
    Author: Ryan Ferguson

#>
param (
    [string]$ServerCSV = "ServerList.csv",
    [string]$OutputDir,
    [string]$TestOutputFile = "SQLConnectionTest.csv",
    [string]$LogFile = "ava-rundma.log",
    [switch]$TestConnections = $false,
    [switch]$OverwriteOutput = $false,
    [switch]$PaasAssessment = $false,
    [switch]$SQLMIAssessment = $false,
    [switch]$GenerateSampleCSV = $false,
    [switch]$Help = $false,
    [ValidateSet("SqlServer2012", "SqlServer2014", "SqlServer2016", "SqlServerLinux2017","SqlServerWindows2017")][string]$OnPremAssessment
)

function CreateDir {
    param(
      [string]$NewPath  
    )
    If (!(test-path $NewPath)){
        write-host "Creating $NewPath"
        New-Item -ItemType directory -force -Path $NewPath|Out-Null
    } 
}

function TestSQL {
    $Success = 0
    $Failed = 0
    $Total = 0
    $log = "Server,Status,Error`r"
    $Length = $($ServerCSVList|Measure-object).count
    write-host "Time: $(get-date)" -ForegroundColor Cyan
    write-host "Testing SQL Connectivity..." -ForegroundColor DarkMagenta
    write-host $log
    foreach ($i in $ServerCSVList) {
        $Total = $Total + 1
        #Set the authentication string based on the input file
        if ($i.AuthMethod -eq "Windows") {
            $Authmode = ";Integrated Security=true;"
        }
        else {
            $Authmode = ";User Id=$($i.UserID);Password=$($i.Password);" 
        }

        $databaseconnections = ""
       
        $ServerInstance = ""
        $ServerInstance = $i.Instance.Replace("MSSQLSERVER", "")
        $ServerInstance = $ServerInstance.Replace("\","")
        if ($ServerInstance -eq "") {
            $newstring = "Server=$($i.Server);Initial Catalog=master;"        
            
        }
        else {
            $newstring = "Server=$($i.Server)\$ServerInstance;Initial Catalog=master;"        
        }

        $newstring += $Authmode
        $databaseconnections = $databaseconnections + $newstring
    
        #$databaseconnections = $databaseconnections.TrimEnd(' """') + '"'
               
        try {
            write-host "Testing $Total of $Length : $($i.Server)\$ServerInstance"
            $sqlConnection = New-Object System.Data.SqlClient.SqlConnection
        
            $sqlConnection.ConnectionString = $databaseconnections
                
            $sqlConnection.Open()
            ## This will run if the Open() method does not throw an exception
            write-host "$Total :$($i.server), Connection Successful" -ForegroundColor Green
            $log = $log + $i.server + ",Connection Successful`r"
            $Success = $Success + 1
        }
        catch {
            $MyError = $($_.Exception.Message).replace("Exception calling ""Open"" with ""0"" argument(s): ", "")
            write-host "$Total :$($i.server), Connection Failed, $MyError" -ForegroundColor Red
            $log = $log + $i.server + ",Connection Failed,""$MyError""`r"
            $Failed = $Failed + 1
        }
        finally {
            ## Close the connection when we're done
            $sqlConnection.Close()
        }
    
    }
    $OutputFile = [IO.Path]::Combine($OutputDir, $TestOutputFile)
    $log | out-file $OutputFile -encoding UTF8 -force
    write-host "`nConnectivity Test Completed..." -ForegroundColor DarkMagenta
    write-host "$Success - Successful Connections" -ForegroundColor Green
    write-host "$Failed - Failed Conenctions" -ForegroundColor Red
    write-host "Time: $(get-date)" -ForegroundColor Cyan
}
 

function RunAssessment{
    param(        
        [string]$AssessmentType
    )

    $DMAexe = "C:\Program Files\Microsoft Data Migration Assistant\DmaCmd.exe"
    $DMATargetPlatformOnPrem = "/AssessmentTargetPlatform=$OnPremAssessment" 
    $DMATargetPlatformSQLMI = "/AssessmentTargetPlatform=ManagedSqlServer" 
    $DMATargetPlatformPaaS = "/AssessmentTargetPlatform=AzureSqlDatabase" 

    $DMAFeatureParity = "/AssessmentEvaluateFeatureParity" #Only valid if target is AzureSqlDatabaseV12
    $DMAAssessmentRecommendations = "/AssessmentEvaluateRecommendations" #not advisable to run this at the same time as compatibility checks
    $DMAAssessmentCompatibility = "/AssessmentEvaluateCompatibilityIssues"


    if ($ServerInstance -eq "") {
        $newstring = """Server=$($i.Server);"        
        
    }
    else {
        $newstring = """Server=$($i.Server)\$ServerInstance;"        
    }

    $databaseconnections = $newstring + $Authmode + """"

    $DMADatabases = "/AssessmentDatabases=" + $databaseconnections
    $DMAResultFileStart = "DMA_Assessment_" + $i.Server.replace(",", "") + "_" + $i.Instance.replace("\", "")
    $DMAAssessmentName = '/AssessmentName=' + $DMAResultFileStart 

    if ($OverwriteOutput){
    $DMAResultOverwrite = "/AssessmentOverwriteResult"
    }
    else {
        $DMAResultOverwrite = ""
    }

    write-host "Time: $(get-date)"  -ForegroundColor Cyan
    write-host "Assessing $($i.Server)\$ServerInstance for $AssessmentType..."

    $DMAResultFileJSON = [IO.Path]::Combine($DMAOutputLocation,"AssessmentJSON", $DMAResultFileStart + "_$AssessmentType.json")

    $DMAResultFileCSV = [IO.Path]::Combine($DMAOutputLocation,"AssessmentCSV", $DMAResultFileStart + "_$AssessmentType.csv")

    switch ($AssessmentType){
        "$($OnPremAssessment)_Compat" {$argumentlist = "$DMAAssessmentName $DMADatabases $DMATargetPlatformOnPrem $DMAAssessmentCompatibility $DMAResultOverwrite /AssessmentResultJson=$DMAResultFileJSON /AssessmentResultCSV=$DMAResultFileCSV"}
        "$($OnPremAssessment)_Feature" {$argumentlist = "$DMAAssessmentName $DMADatabases $DMATargetPlatformOnPrem $DMAAssessmentRecommendations $DMAResultOverwrite /AssessmentResultJson=$DMAResultFileJSON /AssessmentResultCSV=$DMAResultFileCSV"}
        "SQLMI_Compat" {$argumentlist = "$DMAAssessmentName $DMADatabases $DMATargetPlatformSQLMI $DMAAssessmentCompatibility $DMAResultOverwrite /AssessmentResultJson=$DMAResultFileJSON /AssessmentResultCSV=$DMAResultFileCSV"}
        "SQLMI_Feature" {$argumentlist = "$DMAAssessmentName $DMADatabases $DMATargetPlatformSQLMI $DMAFeatureParity $DMAResultOverwrite /AssessmentResultJson=$DMAResultFileJSON /AssessmentResultCSV=$DMAResultFileCSV"}
        "SQLPaaS_Compat" {$argumentlist = "$DMAAssessmentName $DMADatabases $DMATargetPlatformPaaS $DMAAssessmentCompatibility $DMAResultOverwrite /AssessmentResultJson=$DMAResultFileJSON /AssessmentResultCSV=$DMAResultFileCSV"}
        "SQLPaaS_Feature" {$argumentlist = "$DMAAssessmentName $DMADatabases $DMATargetPlatformPaaS $DMAFeatureParity $DMAResultOverwrite /AssessmentResultJson=$DMAResultFileJSON /AssessmentResultCSV=$DMAResultFileCSV"}
    }

    if (!($(test-path $DMAResultFileJSON) -and !($OverwriteOutput))) {

        try {
            $TempLogFile = [IO.Path]::Combine($LogDir, $DMAResultFileStart + "_$AssessmentType.log")
            $global:CommandList = $global:CommandList + """" + $DMAexe + """ " + $argumentlist + "`r`n"
            Start-Process $DMAexe -ArgumentList $argumentlist -Wait -RedirectStandardOutput $TempLogFile -WindowStyle Minimized

        }
        catch {
            write-host("Unable to start DMA process") -ForegroundColor Red
            $Error[0] | Format-List -Force
        } 
        $Success=select-string "Succeeded" $TempLogFile
        $Failed=select-string "Failed" $TempLogFile
        
        
        If ($Success -and $Failed){
            write-host "Completed $AssessmentType Assessment for Server: $($i.Server)\$ServerInstance.  Successful = $($($Success -split":")[4]) Failed = $($($Failed -split":")[4])"
        }else{
            write-host "Error - Please check: $TempLogFile" -ForegroundColor red
        } 
    }
    else{
        write-host "File $DMAResultFileJSON already exists.  Skipping.  Use -OverwriteOutput or remove the files in the output directory to re-run the assessment."   
    }    


}

function AssessServers {
    write-host 'Starting Server Assessment...' -ForegroundColor DarkMagenta
    
    $DMAOutputLocation = $OutputDir
  
        $CommandList = ""
    $Length = $($ServerCSVList|Measure-object).count
    $Count = 0

    foreach ($i in $ServerCSVList) {
        $Count = $Count + 1
        $StartTime = Get-Date 
        #Set the authentication string based on the input file
        if ($i.AuthMethod -eq "Windows") {
            $Authmode = ";Integrated Security=true;"
        }
        else {
            $Authmode = ";User Id=$($i.UserID);Password=$($i.Password);" 
        }

        #$databaseconnections = ""
       
        #generating the DMA Script for all databases.
    
        $ServerInstance = ""
        $ServerInstance = $i.Instance.Replace("MSSQLSERVER", "")
        $ServerInstance = $ServerInstance.Replace("\","")

                
        write-host "Assessing Server $Count of $Length : $($i.Server)  Instance: $ServerInstance  Using Auth Method: $($i.AuthMethod)" -ForegroundColor DarkMagenta
        write-host "Start Time: $starttime" -ForegroundColor DarkMagenta
        $teststring = "Server=$($i.Server)\$ServerInstance;Initial Catalog=master"        
        $teststring += $Authmode
        $MyError=""
        try {
            $sqlConnection = New-Object System.Data.SqlClient.SqlConnection
            $sqlConnection.ConnectionString = $teststring    
            $sqlConnection.Open()
            ## This will run if the Open() method does not throw an exception
            $LiveConnection = $True
        }
        catch {
            $LiveConnection =  $False
            $MyError = $($_.Exception.Message).replace("Exception calling ""Open"" with ""0"" argument(s): ", "")
        }
        finally {
            ## Close the connection when we're done
            $sqlConnection.Close()
        }

        if ($LiveConnection) {

            createdir -newpath $([IO.Path]::Combine($DMAOutputLocation,"AssessmentJSON"))
            createdir -newpath $([IO.Path]::Combine($DMAOutputLocation,"AssessmentCSV"))
            
            $LogDir = $([IO.Path]::Combine($DMAOutputLocation,"Log"))
            createdir -newpath $LogDir
                   
            if ($OnPremAssessment) {
                RunAssessment -AssessmentType "$($OnPremAssessment)_Compat"
                RunAssessment -AssessmentType "$($OnPremAssessment)_Feature"
            }

            if ($SQLMIAssessment) {
                RunAssessment -AssessmentType "SQLMI_Compat"
                RunAssessment -AssessmentType "SQLMI_Feature"
            }

            if ($PaasAssessment) {
                RunAssessment -AssessmentType "SQLPaaS_Compat"
                RunAssessment -AssessmentType "SQLPaaS_Feature"
            }

        }
        else{
            write-host "Failed Connection: $($i.Server)\$ServerInstance"
            write-host "Can not connect to server.  Please Diagnose...  $MyError" -ForegroundColor red
        }
        write-host "Completed Assessment for Server: $($i.Server)\$ServerInstance."   -ForegroundColor DarkMagenta
     $TotalTime = New-TimeSpan -start $StartTime -End $(get-date)
     write-host "Time: $(get-date)"  -ForegroundColor DarkMagenta
     write-host "Processing for Server: $($i.Server)\$ServerInstance.  Total minutes taken: " + $TotalTime.TotalMinutes -ForegroundColor DarkMagenta
    }
    $OutputFile = [IO.Path]::Combine($DMAOutputLocation, "CommandList.bat")
    $global:CommandList | out-file $OutputFile

}

$global:CommandList = ""

#Start of the main program code that runs with the script...
if (!$OutputDir) {
    $OutputDir = Split-Path -Parent -Path $MyInvocation.MyCommand.Definition
}
if ($Help -or ($PSBoundParameters.count -eq 0)) {
    Get-Help $MyInvocation.MyCommand.Definition
    return
}
elseif ($GenerateSampleCSV) {
    write-host "Generating sample CSV:  $ServerCSV"
    $Header="Server,Instance,AuthMethod,UserID,Password`n"
    $Header+="""MyServer-DefultInstance-WindowsAuth"",,Windows,,`n"
    $Header+="""MyServer-DefultInstance-SQLAuth"",""MSSQLSERVER"",SQL,""userid"",""mycoolpassword""`n"
    $Header+="""MyServer-NamedInstance-SQLAuth"",""MyNamedInstance"",SQL,""userid"",""mycoolpassword""`n"
    $Header|out-file $ServerCSV -NoClobber -encoding UTF8 
}
else{
    $MasterLog = [IO.Path]::Combine($OutputDir, $LogFile)
    Start-Transcript -path $MasterLog  -Force
    $StartMaster = get-date
        write-host "Importing CSV: $ServerCSV" -ForegroundColor Green
    $ServerCSVList = Import-Csv -Path $ServerCSV
    if (!$ServerCSVList) {
        write-host "There are no servers within the file.  Please complete $ServerCSV"
        write-host "The header of the CSV is ""Server,Instance,AuthMethod,UserID,Password"".  AuthMehod is either Windows or SQL"
        exit
    }
    $Length = $($ServerCSVList|Measure-object).count
    write-host "Instances in CSV: " $Length -ForegroundColor Green
    
    if ($TestConnections) {
        TestSQL
    }
    elseif ($SQLMIAssessment -or $PaasAssessment -or $OnPremAssessment) {
         AssessServers
        }
        
    else {
        Get-Help $MyInvocation.MyCommand.Definition
        return
    }
    $TotalTime = New-TimeSpan -start $StartMaster -End $(get-date)
    write-host "Total minutes taken: " + $TotalTime.TotalMinutes -ForegroundColor DarkMagenta
    Stop-Transcript
}

